---
sidebar_position: 3
---

# 1.3 Services, Actions, and Parameters: Advanced Communication Patterns

## Learning Objectives

By the end of this chapter, you should be able to:
- Understand the request/response communication pattern using services
- Implement and use ROS 2 actions for long-running tasks
- Configure and manage parameters in ROS 2 systems
- Choose appropriate communication patterns for different scenarios
- Design robust communication architectures for robotic systems

## Concept Explanation

### Services in ROS 2

**Services** provide a request/response communication pattern in ROS 2. Unlike topics which use a publish/subscribe model, services establish a direct connection between a client and a server for synchronous communication. The key characteristics of services are:

- **Synchronous**: The client waits for a response from the server
- **Request/Response**: Each request gets exactly one response
- **Direct Connection**: Client and server communicate directly
- **Blocking**: The client is blocked until it receives a response

Services are ideal for operations that have a clear input/output relationship and can be completed relatively quickly, such as:
- Calibration routines
- Configuration changes
- Simple computations
- Database queries

### Actions in ROS 2

**Actions** are designed for long-running tasks that require feedback and goal management. They combine aspects of both topics and services, providing:

- **Goal Management**: Clients can send goals and cancel them if needed
- **Feedback**: Continuous feedback during task execution
- **Result**: Final result upon completion
- **Preemption**: Ability to interrupt and replace ongoing tasks

Actions are perfect for tasks like:
- Navigation to a specific location
- Arm manipulation sequences
- Mapping operations
- Any task that takes a significant amount of time

### Parameters in ROS 2

**Parameters** are configuration values that can be set at runtime and shared between nodes. They provide a way to configure robot behavior without recompiling code. Parameters in ROS 2 have:

- **Dynamic Reconfiguration**: Parameters can be changed at runtime
- **Node-specific**: Each node can have its own set of parameters
- **Type Safety**: Parameters have defined types (int, float, string, bool, lists)
- **Hierarchical**: Parameter names follow a dot notation for organization

## Practical Context (Robotics / Physical AI)

### Service Applications in Robotics

Services are commonly used in robotics for operations that require immediate responses:

- **Calibration Services**: Requesting sensor calibration
- **Mode Switching**: Changing robot operational modes
- **Data Retrieval**: Getting current robot state or configuration
- **Simple Control**: Triggering specific behaviors or actions

For example, a service might be used to calibrate a camera when the robot enters a new environment, or to request the current battery status.

### Action Applications in Physical AI

Actions are essential for complex, time-consuming tasks in physical AI:

- **Navigation**: Moving to specific locations with real-time feedback on progress
- **Manipulation**: Complex arm movements with feedback on joint positions
- **Planning**: Generating paths with feedback on planning progress
- **Learning**: Training processes with feedback on progress

Actions allow for more sophisticated interaction with long-running processes, enabling robots to perform complex tasks while providing continuous feedback to higher-level systems.

### Parameter Management in Robotic Systems

Parameters enable runtime configuration of robotic systems:

- **Control Gains**: Tuning PID controller parameters
- **Sensor Settings**: Adjusting sensor sensitivity or thresholds
- **Behavior Parameters**: Modifying robot behavior characteristics
- **Safety Limits**: Setting velocity or force limits

Parameters allow for system tuning without code changes, making robots more adaptable to different environments and tasks.

## Examples

### Service Definition and Implementation

First, let's define a service for robot calibration:

```
# Calibration.srv
# Request
string sensor_type
float64 timeout
---
# Response
bool success
string message
```

### Service Server Implementation

```python
import rclpy
from rclpy.node import Node
from my_robot_msgs.srv import Calibration  # Custom service

class CalibrationService(Node):

    def __init__(self):
        super().__init__('calibration_service')
        self.srv = self.create_service(
            Calibration,
            'calibrate_sensor',
            self.calibrate_sensor_callback
        )

    def calibrate_sensor_callback(self, request, response):
        self.get_logger().info(f'Calibrating {request.sensor_type} sensor...')

        # Simulate calibration process
        if request.sensor_type == 'camera':
            # Perform camera calibration
            success = self.perform_camera_calibration()
        elif request.sensor_type == 'lidar':
            # Perform LIDAR calibration
            success = self.perform_lidar_calibration()
        else:
            success = False

        response.success = success
        if success:
            response.message = f'{request.sensor_type} calibration completed successfully'
        else:
            response.message = f'{request.sensor_type} calibration failed'

        return response

    def perform_camera_calibration(self):
        # Simulate camera calibration process
        self.get_logger().info('Performing camera calibration...')
        # In a real implementation, this would contain actual calibration logic
        return True

    def perform_lidar_calibration(self):
        # Simulate LIDAR calibration process
        self.get_logger().info('Performing LIDAR calibration...')
        # In a real implementation, this would contain actual calibration logic
        return True

def main(args=None):
    rclpy.init(args=args)
    calibration_service = CalibrationService()
    rclpy.spin(calibration_service)
    calibration_service.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Service Client Implementation

```python
import rclpy
from rclpy.node import Node
from my_robot_msgs.srv import Calibration

class CalibrationClient(Node):

    def __init__(self):
        super().__init__('calibration_client')
        self.cli = self.create_client(Calibration, 'calibrate_sensor')
        while not self.cli.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Service not available, waiting again...')

    def send_calibration_request(self, sensor_type, timeout=10.0):
        request = Calibration.Request()
        request.sensor_type = sensor_type
        request.timeout = timeout

        self.future = self.cli.call_async(request)
        rclpy.spin_until_future_complete(self, self.future)

        if self.future.result() is not None:
            response = self.future.result()
            self.get_logger().info(f'Response: {response.success}, {response.message}')
            return response
        else:
            self.get_logger().error('Service call failed')
            return None

def main(args=None):
    rclpy.init(args=args)
    calibration_client = CalibrationClient()

    # Calibrate camera
    result = calibration_client.send_calibration_request('camera')

    # Calibrate LIDAR
    result = calibration_client.send_calibration_request('lidar')

    calibration_client.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Action Implementation

First, let's define an action for navigation:

```
# NavigateToPose.action
# Goal
geometry_msgs/Pose target_pose
float64 tolerance
---
# Result
bool success
string message
float64 distance_traveled
---
# Feedback
geometry_msgs/Pose current_pose
float64 distance_to_goal
string status
```

### Action Server Implementation

```python
import rclpy
from rclpy.action import ActionServer, GoalResponse, CancelResponse
from rclpy.node import Node
from rclpy.callback_groups import ReentrantCallbackGroup
from rclpy.executors import MultiThreadedExecutor
import threading
import time
from my_robot_msgs.action import NavigateToPose
from geometry_msgs.msg import Pose
from std_msgs.msg import Float64

class NavigateToPoseActionServer(Node):

    def __init__(self):
        super().__init__('navigate_to_pose_action_server')
        self._action_server = ActionServer(
            self,
            NavigateToPose,
            'navigate_to_pose',
            execute_callback=self.execute_callback,
            goal_callback=self.goal_callback,
            cancel_callback=self.cancel_callback,
            callback_group=ReentrantCallbackGroup())

        # For simulation purposes
        self.current_pose = Pose()
        self.current_pose.position.x = 0.0
        self.current_pose.position.y = 0.0
        self.current_pose.position.z = 0.0
        self.current_pose.orientation.w = 1.0

    def goal_callback(self, goal_request):
        """Accept or reject a client request to begin an action."""
        self.get_logger().info('Received goal request')
        return GoalResponse.ACCEPT

    def cancel_callback(self, goal_handle):
        """Accept or reject a client request to cancel an action."""
        self.get_logger().info('Received cancel request')
        return CancelResponse.ACCEPT

    def execute_callback(self, goal_handle):
        """Execute the goal."""
        self.get_logger().info('Executing goal...')

        feedback_msg = NavigateToPose.Feedback()
        feedback_msg.current_pose = self.current_pose
        feedback_msg.distance_to_goal = 10.0  # Simulated distance
        feedback_msg.status = 'Navigating'

        # Simulate navigation process
        for i in range(0, 101, 10):
            if goal_handle.is_cancel_requested:
                goal_handle.canceled()
                result = NavigateToPose.Result()
                result.success = False
                result.message = 'Goal canceled'
                result.distance_traveled = 0.0
                return result

            # Update feedback
            feedback_msg.distance_to_goal = 10.0 - (i / 10.0)
            feedback_msg.status = f'Navigating: {i}% complete'
            goal_handle.publish_feedback(feedback_msg)

            # Simulate movement
            time.sleep(0.5)

        # Goal completed
        goal_handle.succeed()
        result = NavigateToPose.Result()
        result.success = True
        result.message = 'Navigation completed successfully'
        result.distance_traveled = 10.0

        return result

def main(args=None):
    rclpy.init(args=args)
    action_server = NavigateToPoseActionServer()

    executor = MultiThreadedExecutor()
    rclpy.spin(action_server, executor=executor)

    action_server.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Parameter Management Example

```python
import rclpy
from rclpy.node import Node
from rclpy.parameter import Parameter
from rclpy.qos import qos_profile_parameters
from rcl_interfaces.msg import SetParametersResult

class RobotController(Node):

    def __init__(self):
        super().__init__('robot_controller')

        # Declare parameters with default values
        self.declare_parameter('max_velocity', 0.5)
        self.declare_parameter('acceleration_limit', 1.0)
        self.declare_parameter('control_frequency', 50)
        self.declare_parameter('safety_distance', 0.5)

        # Get parameter values
        self.max_velocity = self.get_parameter('max_velocity').value
        self.acceleration_limit = self.get_parameter('acceleration_limit').value
        self.control_frequency = self.get_parameter('control_frequency').value
        self.safety_distance = self.get_parameter('safety_distance').value

        # Create timer for control loop
        self.timer = self.create_timer(1.0/self.control_frequency, self.control_loop)

        # Add callback for parameter changes
        self.add_on_set_parameters_callback(self.parameter_callback)

        self.get_logger().info(f'Controller initialized with max_velocity: {self.max_velocity}')

    def parameter_callback(self, params):
        """Callback for parameter changes."""
        for param in params:
            if param.name == 'max_velocity':
                if param.value > 2.0:  # Safety limit
                    return SetParametersResult(successful=False, reason='Max velocity too high')
                self.max_velocity = param.value
                self.get_logger().info(f'Max velocity updated to: {self.max_velocity}')
        return SetParametersResult(successful=True)

    def control_loop(self):
        # Control logic using parameters
        self.get_logger().info(f'Control loop running at {self.control_frequency}Hz')

def main(args=None):
    rclpy.init(args=args)
    robot_controller = RobotController()

    # Example of changing parameters programmatically
    # This would typically be done externally
    rclpy.spin(robot_controller)

    robot_controller.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Chapter Summary

This chapter covered advanced communication patterns in ROS 2:

- **Services** provide request/response communication for synchronous operations
- **Actions** enable long-running tasks with feedback, goal management, and cancellation
- **Parameters** allow runtime configuration of nodes without code changes
- Each communication pattern has specific use cases and advantages
- Choosing the right pattern is crucial for effective robotic system design

These advanced communication mechanisms complement the basic publish/subscribe pattern, providing the tools needed to build sophisticated robotic applications. Services handle immediate request/response needs, actions manage complex long-running tasks, and parameters enable dynamic configuration, together forming a comprehensive communication framework for robotic systems.