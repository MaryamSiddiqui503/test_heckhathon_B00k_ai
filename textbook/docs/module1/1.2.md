---
sidebar_position: 2
---

# 1.2 Nodes, Topics, and Messages: The Communication Backbone

## Learning Objectives

By the end of this chapter, you should be able to:
- Understand the concept of nodes and their role in ROS 2
- Explain the publish/subscribe communication pattern using topics
- Create and use custom message types
- Implement node communication in ROS 2
- Design effective message passing architectures

## Concept Explanation

### Nodes in ROS 2

In ROS 2, a **node** is a process that performs computation. Nodes are the fundamental building blocks of a ROS 2 system, and they are designed to be modular and focused on specific tasks. Each node typically handles a single responsibility, such as:

- Sensor data acquisition and preprocessing
- Control algorithm implementation
- State estimation
- Path planning
- User interface management

Nodes communicate with each other through various mechanisms including topics, services, and actions. This modular approach allows for the creation of complex robotic systems from simple, reusable components.

### Topics and Publish/Subscribe Pattern

**Topics** in ROS 2 implement a publish/subscribe communication pattern. This pattern allows nodes to exchange messages without having direct knowledge of each other. The key characteristics of the publish/subscribe pattern are:

- **Decoupling**: Publishers and subscribers don't need to know about each other
- **Asynchronous**: Communication happens independently of the sender and receiver
- **Many-to-many**: Multiple publishers can send to a topic, and multiple subscribers can receive from it
- **Data-centric**: Communication is based on the topic name and message type

When a node wants to send data, it publishes messages to a topic. When a node wants to receive data, it subscribes to a topic. The ROS 2 middleware handles the routing of messages between publishers and subscribers.

### Messages

**Messages** are the data structures that are passed between nodes. Each message has a specific type that defines its structure and content. ROS 2 comes with many standard message types, but users can also define custom message types.

Message types are defined using a special interface definition language (IDL) that specifies the fields and their data types. Common data types include integers, floats, booleans, strings, arrays, and other messages.

## Practical Context (Robotics / Physical AI)

### Node Design Patterns in Robotics

In robotic systems, nodes are typically organized around specific functions:

- **Sensor Nodes**: Publish raw sensor data like camera images, LIDAR scans, or IMU readings
- **Perception Nodes**: Process sensor data to extract meaningful information like object detection or mapping
- **Planning Nodes**: Generate trajectories or action plans based on goals and current state
- **Control Nodes**: Execute low-level commands to actuators based on high-level commands
- **Interface Nodes**: Handle communication with external systems or user interfaces

### Communication Patterns in Physical AI

The publish/subscribe pattern is particularly useful in physical AI systems because:

- **Real-time constraints**: Asynchronous communication allows for non-blocking operations
- **Modularity**: Different AI components can be developed and tested independently
- **Scalability**: Additional nodes can be added without modifying existing ones
- **Robustness**: Failure of one node doesn't necessarily affect others

For example, in a humanoid robot:
- Multiple sensor nodes publish data to different topics
- Perception nodes subscribe to relevant sensor topics and publish processed information
- Decision-making nodes subscribe to processed data and publish commands
- Control nodes subscribe to commands and execute them on the physical robot

## Examples

### Custom Message Definition

First, let's define a custom message for robot status:

```
# RobotStatus.msg
uint8 IDLE=0
uint8 MOVING=1
uint8 MANIPULATING=2
uint8 ERROR=3

uint8 status
float64 battery_level
bool emergency_stop
string current_task
geometry_msgs/Pose current_pose
```

### Publisher Node with Custom Message

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String
from geometry_msgs.msg import Pose
from my_robot_msgs.msg import RobotStatus  # Custom message

class RobotStatusPublisher(Node):

    def __init__(self):
        super().__init__('robot_status_publisher')
        self.publisher_ = self.create_publisher(RobotStatus, 'robot_status', 10)
        timer_period = 1.0  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)

        # Initialize pose
        self.current_pose = Pose()
        self.current_pose.position.x = 0.0
        self.current_pose.position.y = 0.0
        self.current_pose.position.z = 0.0
        self.current_pose.orientation.x = 0.0
        self.current_pose.orientation.y = 0.0
        self.current_pose.orientation.z = 0.0
        self.current_pose.orientation.w = 1.0

    def timer_callback(self):
        msg = RobotStatus()
        msg.status = RobotStatus.IDLE
        msg.battery_level = 0.85  # 85% battery
        msg.emergency_stop = False
        msg.current_task = 'waiting_for_command'
        msg.current_pose = self.current_pose

        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing robot status: {msg.status}')

def main(args=None):
    rclpy.init(args=args)
    robot_status_publisher = RobotStatusPublisher()
    rclpy.spin(robot_status_publisher)
    robot_status_publisher.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Subscriber Node

```python
import rclpy
from rclpy.node import Node
from my_robot_msgs.msg import RobotStatus

class RobotStatusSubscriber(Node):

    def __init__(self):
        super().__init__('robot_status_subscriber')
        self.subscription = self.create_subscription(
            RobotStatus,
            'robot_status',
            self.listener_callback,
            10)
        self.subscription  # prevent unused variable warning

    def listener_callback(self, msg):
        self.get_logger().info(f'Robot Status: {msg.status}')
        self.get_logger().info(f'Battery Level: {msg.battery_level}')
        self.get_logger().info(f'Current Task: {msg.current_task}')

        if msg.emergency_stop:
            self.get_logger().warn('EMERGENCY STOP ACTIVATED!')

def main(args=None):
    rclpy.init(args=args)
    robot_status_subscriber = RobotStatusSubscriber()
    rclpy.spin(robot_status_subscriber)
    robot_status_subscriber.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Multiple Publishers and Subscribers Example

```python
# Sensor fusion example
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import LaserScan, Image
from geometry_msgs.msg import Twist

class SensorFusionNode(Node):

    def __init__(self):
        super().__init__('sensor_fusion_node')

        # Subscribe to multiple sensor topics
        self.laser_subscription = self.create_subscription(
            LaserScan,
            'laser_scan',
            self.laser_callback,
            10)

        self.camera_subscription = self.create_subscription(
            Image,
            'camera/image_raw',
            self.camera_callback,
            10)

        # Publish fused data
        self.cmd_vel_publisher = self.create_publisher(Twist, 'cmd_vel', 10)

    def laser_callback(self, msg):
        # Process laser scan data
        min_distance = min(msg.ranges)
        if min_distance < 0.5:  # Less than 50cm to obstacle
            # Stop the robot
            cmd_msg = Twist()
            cmd_msg.linear.x = 0.0
            cmd_msg.angular.z = 0.0
            self.cmd_vel_publisher.publish(cmd_msg)

    def camera_callback(self, msg):
        # Process camera data
        # For example, detect red objects and turn toward them
        pass

def main(args=None):
    rclpy.init(args=args)
    sensor_fusion_node = SensorFusionNode()
    rclpy.spin(sensor_fusion_node)
    sensor_fusion_node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Chapter Summary

This chapter explored the fundamental communication mechanisms in ROS 2:

- **Nodes** serve as the basic computational units in ROS 2, each performing specific tasks
- **Topics** implement the publish/subscribe pattern, enabling decoupled communication
- **Messages** are the data structures passed between nodes, supporting both standard and custom types
- The publish/subscribe pattern provides modularity, scalability, and robustness for robotic systems
- Practical examples demonstrated how to create publishers, subscribers, and handle multiple data streams

These communication primitives form the backbone of complex robotic systems, allowing different components to work together seamlessly while maintaining modularity and flexibility. Understanding these concepts is crucial for building effective robotic applications with ROS 2.